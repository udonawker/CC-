## サイズを表す整数型
&lt;cstddef&gt;ヘッダおよび&lt;stddef.h&gt;では、sizeof演算子が返す符号なし整数型であるstd::size_t型が定義されています。<br/>
この型は、コンテナの要素数や添字の型としても使用されます。<br/>

## 変数
<pre>
型名 変数名 《= 初期化子》 ;
</pre>

## 配列
<pre>
型名 変数名[要素数] 《= 初期化子》 ;
</pre>

## ポインタ
《cv修飾子》 型名*《cv修飾子》 変数名 《= 初期化子》 ;

<pre>
int a = 0;
int* b = &a; // bはaのアドレスを保持するポインタオブジェクト
*b = 10; // aに10が代入される

int c[10] = {}; // 要素数10個、0で初期化された配列
int *d = c;     // dは配列cの先頭アドレスを保持するポインタオブジェクト
d[4] = 10;      // d[4]に10が代入される

int* f[10];     // 「int型へのポインタ」の要素を10個持つ配列
int** e = f;    // 「int型へのポインタ」へのポインタ
e[4] = nullptr; // f[4]にnullptrを代入
</pre>

### オブジェクトのアドレスを取得するには
&演算子はオーバーロードできます。このため、オブジェクトのアドレスを正しく取得できない可能性があります。<br/>
C++11以降の&lt;memory&gt;ヘッダで定義されているstd::addressof()関数を使用すると、オブジェクトの型に対する&演算子がオーバーロードされている／いないに関わらず、そのオブジェクトのアドレスを取得できます。<br/>
<pre>
X x;
X* p = addressof(x); // 変数xのアドレスを取得
</pre>

## 関数ポインタ
<pre>
戻り値の型 (*変数名)(仮引数リスト) 《= 初期化子》 ;
</pre>
<pre>
int square(int v) { return v * v; }
int (*f)(int) = square; // fは関数squareのアドレスを保持する関数ポインタオブジェクト
int result = f(5);      // 実引数5でsquareが呼ばれる。結果は25
</pre>
