# 右辺値参照とムーブセマンティクス @version_C++11

## 右辺値参照とは
 C++03までは「コピー」という概念でデータが管理されていました。通常「a = b;」という四季は「bをaにコピーする」という意味を持ちます。このとき、aとbは同じデータを異なる領域に持ちます。これは小さいデータの場合には問題になりにくいですが、大きなデータを扱う場合に、コピーコストと、同じデータが2つできてしますことが問題となります。<br>
 この問題に対処するには、C++11から追加されたムーブセマンティクスという概念と、その言語機能である右辺値参照を使用します。<br>
 たとえば、以下のケースを考えてみましょう。<br>

<pre>
vector<X> make_data() {
    vector<X> v;
    …大量のデータを追加する…
    return v;
}

vector<X> v = make_data();
</pre>

 ここでは、大きな要素数を持つ可変長配列オブジェクトを、関数のreturn文で返し、それを新たな可変長配列オブジェクトで受け取っています。<br>
 その際、make_data()関数が返すオブジェクトからオブジェクトvへのコピーが発生します。make_data()関数によって返されたオブジェクトは、その関数が評価された後は消えてしまうことから、一時オブジェクトと呼ばれます。<br>
 C++11から追加された機能である右辺値参照は、一時オブジェクトを参照する機能です。C++11のstd::vectorクラスでは、一時オブジェクトを参照するコンストラクタが追加されています。以下に、疑似実装を紹介します。<br>

<pre>
template <class T, class Allocator=allocator<T>>
class vector {
    T* data_;
    size_t size_;
public:
    …
    // 一時オブジェクトを参照するコンストラクタ
    vector(vector&& x) {
        data_ = x.data_;
        size_ = x.size_;
        x.data_ = nullptr;
        x.size_ = 0;
    }
    
    // これまで通りのコピーコンストラクタ
    vector(const vector& x) {
        // xのコピーを生成する…
    }
};
</pre>

 一時オブジェクトを参照する右辺値参照には、&&という記号を使用します。&&が付いた仮引数を受け取る関数は、その型の一時オブジェクトを受け取ります。一時オブジェクトは、評価されたらすぐに破棄されるので、多くの場面で破壊しても構わないものとして扱えます。<br>
 std::vectorクラスの、右辺値参照を受け取るコンストラクタでは、一時オブジェクトが持つデータ(可変長配列を表すポインタ、サイズ、その他のデータ)を*thisに繋ぎ変えたあと、一時オブジェクトが持つデータを無効にしています。こうすることで、大きなデータのコピーコストを気にすることなく扱えます。<br>

## move()関数
 <utility>ヘッダでは、オブジェクトをむーぶするための機能として、std::move()関数が定義されています。この関数は、オブジェクトを一時オブジェクトに変換し、右辺値参照をとる関数が呼ばれるようにします。<br>

<pre>
vector<X> v1;
vector<X> v2 = move(v1); // v1をv2にムーブする
</pre>

 前述の一時オブジェクトを受け取るコンストラクタで示したように、ムーブ後のv1オブジェクトは無効になります。<br>

## ムーブコンストラクタとムーブ代入演算子
 自身の型の右辺値参照を仮引数に取るコンストラクタをムーブコンストラクタと呼びます。同様に、右辺値参照を仮引数にとる代入演算子をムーブ代入演算子と呼びます。<br>
 これらの関数は、コピーコンストラクタとコピー代入演算子と同様、暗黙的に定義されます。<br>

<pre>
class X {
    vector<int> data_;
    string str_;
public:
    …
    
    // 暗黙に定義されるムーブコンストラクタ
    X(X&& x)
        : data_(move(x.data_)),
          str_(move(x.str_)) {}

    // 暗黙に定義されるムーブ代入演算子
    X& operator=(X&& x) {
        data_ = move(x.data_);
        str_ = move(x.str_);
        return *this;
    }
};
