# 文(ステートメント)
 文は、プログラムの動作の定義と制御を行います。

## 式と式文
 式は、リテラル、名前、演算子などの組み合わせで構成され、値の計算、関数呼び出し、値の代入などを行います。式文は式とセミコロンで構成されます。<br>

<pre>
式;
</pre>

<pre>
// 式文で使用する関数の宣言
int func(int v);

int a, b; // 式文で使用する変数の宣言
// 式文の例
a = 12 + 34; // 式文
b = func(a); // 実引数aでfunc()関数を呼び出した結果をbに代入する式文

func(b); // 実引数bでfunc()関数を呼び出す式文。結果は破棄される
</pre>

 式文では、式を省略できます。式を持たない式文、つまり、セミコロンのみの式文をヌル文と呼びます。<br>

<pre>
; // ヌル文
</pre>

## 複合分
 複合文(ブロック文)は、プログラムの任意の領域を{}で囲むことにより、変数のスコープを作ります。<br>
 ブロック内で宣言されたオブジェクト、プロトタイプ、型定義は、ブロック内のみで有効です。オブジェクトは、ブロックから出ると破棄されます。<br>

## return文
 関数から呼び出し元へ制御を戻します。<br>
 たとえば、int型の仮引数を1つ取り、その値が負数であれば何も処理をせずfalseを戻り値とし、負数でなければ何らかの処理を行ったあとに呼び出し元へ戻る関数func()は、以下のように記述できます。<br>

<pre>
bool func(int value) {
    if (value < 0) {
        return false;
    }

    // 何らかの処理

    return true;
}
</pre>

 戻り値の型がvoid以外の関数から呼び出し元へ戻る場合、main()関数を除き、return文が記述されていない場合の結果は未定義です。main()関数に限り、return文がない場合には、return 0;があるものとみなされます。<br>
 戻り値の型がvoidの関数からreturn文で呼び出し元へ戻る場合、戻り値を書かずに、return文を記述します。ただし、戻り値がvoid型の関数から戻り値がvoid型の関数を呼び出し、その戻り値を返す(実際には何も返らない)場合、以下のように記述できます。<br>

<pre>
void subVoidFunc() {}
void voidFunc() {
    return subVoidFunc(); // 戻り値がvoid型の関数を呼び出す
}
</pre>

## if文
 ある条件が成立する場合のみ行いたい処理があるとき、以下のようにif文を使えば処理を分岐できます。<br>

<pre>
if (条件式)
    // 条件成立時の処理
</pre>

 条件式には、bool値に変換可能な型の変数宣言と初期化も記述できます。<br>
 条件成立時と不成立時で処理を分けたい場合は、else節を用いて、以下のように記述できます。<br>

<pre>
if (条件式)
    // 条件成立時の処理
else
    // 条件不成立時の処理
</pre>

 条件成立時、条件不成立時の処理は、それぞれ複合文を用いて、複数記述できます。<br>

<pre>
if (条件式) {
    // 条件成立時の処理
} else {
    // 条件不成立時の処理
}
</pre>

## 初期化を伴うif文 @version_C++17
 if文では、条件式と文のなかで使用する変数を定義できます。<br>

<pre>
if (初期化式; 条件式)
</pre>

 これを使用して関数の戻り値を条件式で使用して、文のなかでも使用する、というような記述ができます。<br>

<pre>
int f();
void g(int x);

// 変数xを関数f()の戻り値で初期化し、
// xの値が0以外であれば条件成立とする
if (int x = f(); x != 0) {
    // 条件成立時の処理。
    // ここでも変数xを使用できる。
    g(x);
}
</pre>

## switch文
 与えられた条件の結果により処理を分岐する場合は、switch文を使います。条件の結果は、整数型もしくは列挙型でなければなりません。<br>
 以下が書式です。caseには定数式を与えます。<br>

<pre>
switch (条件) {
case 定数式1:
    // 条件の結果が定数式1と一致する場合の処理

case 定数式2:
    // 条件の結果が定数式2と一致する場合の処理

default:
}
</pre>

 defaultは、どのcaseにもあてはまらない場合に実行されます。
 条件の結果がいずれのcaseにも一致しない場合、defaultへ分岐します。defaultがなければ、switch文の中に書かれた処理は何も実行されません。<br>
 caseもしくはdefaultに分岐された処理は、後述するbreak文がなければ、続けて次のcaseまたはdefaultの処理を実行します。<br>

## 初期化をともなうswitch文 @version_C++17
 if文と同じように、switch文でも初期化式と条件を分けられます。<br>

<pre>
switch (初期化式; 条件)
</pre>

 これを使用して、関数の戻り地を条件の値として指定し、switch文のなかでその値を参照する、というような記述ができます。<br>

<pre>
int f();
void g(int x);

// 変数xを関数f()の戻り値で初期化し、
// switch文の条件として変数xの値を使用する
switch (int x = f(); x) {
    case 0:
        ...
        break;

    // 条件に合致しなかった場合に、
    // 条件値xを使用してなにかをする
    default:
        g(x);
        break;
}
</pre>

## while文
 while文は、与えられた条件式が成立している間、処理の実行を繰り返します。<br>
 書式を以下に示します。<br>

<pre>
while (条件式) 処理
</pre>

## do-while文
 do-while文は、処理の後で条件式を判定し、条件式が成立している間、処理の実行を繰り返します。書式を以下に示します。<br>

<pre>
do 処理 while(条件式);
</pre>

## for文
 for文は、初期処理、条件式、式を与えてループ処理を行います。初期処理には、式文もしくは宣言を記述できます。<br>
 for文では、最初に一度だけ初期処理が実行され、次に条件式が評価されます。条件式が成立している間、処理の実行と式の評価が行われます。<br>
 for文の書式を以下に示します。<br>

<pre>
for (初期処理; 条件式; 式) 処理
</pre>

## 範囲for文 @version_C++11
 範囲for文は配列やコンテナの全要素を列挙します。範囲for文の書式を以下に示します。<br>

<pre>
for (要素 : 配列もしくはコンテナ) 処理
</pre>

 たとえば、std::vector<int>のオブジェクトvecの中身すべてを標準出力に表示したいとき、for文で記述すると以下のようになります。<br>

<pre>
for (vector<int>::iterator it = vec.begin(), end = vec.end(); it != end; ++it)
    cout << *it << endl;
</pre>

 これを範囲for文で記述すると、以下のようになります。<br>

<pre>
for (int val : vec)
    cout << val << endl;
</pre>

 このように、範囲for文は、配列やコンテナの中身すべてに対して処理を行う場合に便利です。<br>
 範囲for文は、配列もしくは以下の優先順位のいずれかの条件を満たすクラスに対して使用できます。<br>

* 標準ライブラリのコンテナのように、begin()とend()メンバ関数を持つ
* begin()およびend()非メンバ関数が適用できる

 なお、配列以外のオブジェクトに対して範囲for文を適用する場合、begin()およびend()の返すオブジェクトは、operator *()メンバ関数およびoperator ++()メンバ関数を持っていなければなりません。<br>

## gotoとラベル文
 gotoは、指定されたラベルの箇所へ制御を移します。ラベル分は、以下のように識別子にコロン(:)をつなげたもので、goto文による分岐先を宣言します。<br>

<pre>
識別子:
</pre>

 ラベル分の後には、文が必要です。<br>
 gotoとラベル文の使用例を以下に示します。<br>

<pre>
bool func(int i, int j, int k);

for (int i = 0; i < 10; ++i) {
    for (int j = 0; j < 10; ++j) {
        for (int k = 0; k < 10; ++k) {
            if (func(i, j, k)) { // funcの戻り値がtrueであればgotoで抜ける
                goto label; // labelへ分岐
            }
        }
    }
}

    // なにかの処理。gotoによる分岐が発生すると実行されない
label:
    return;
</pre>

 ラベルを記述する位置に決まりはありませんが、ラベルは行頭から書かれることが多いです。<br>

## break文
 break文は、switch文、while文、do-while文、for文および範囲for文において処理を中断し、文の外へ処理を移行します。<br>
 文が入れ子になっている場合は最も内側の文の外に出るだけです。<br>

## continue文
 continue文は、while文、do-while文、for文、および範囲for文において、現在の処理を中断し、次の条件でループを継続します。<br>
 文が入れ子になっている場合、最も内側の文を継続します。<br>

## tryブロック
 tryブロックは、例外処理を行います。tryブロックの構文は以下のとおりです。<br>

<pre>
try 複合分
catch(例外宣言) 複合分
</pre>

 try節の複合分の中で例外が送出されると、その例外に対応したcatch節の複合文が処理されます。<br>

