# プリプロセッサ
　プリプロセッサは、ファイルの読み込み、マクロの処理、条件付き取り込みの範囲設定など、コンパイルの前処理を行います。<br>

## ファイルの読み込み(#include)
　ソースファイルの任意の位置に指定したファイルを読み込む命令が#includeです。<br>
　ファイルの指定方法は以下のとおり、""と<>の2種類があります。<br>

<pre>
#include "ファイル名"
#include &lt;ファイル名&gt;
</pre>

　この2つの違いは、ファイルの検索順序です。どのような順序でファイルの検索が行われるかは実装定義ですが、GCCやVisual C++などでは以下の順序で行われます。<br>

### ▲&lt;ファイル名&gt;
1. オプションで指定された場所<br>
2. 環境変数などで定義される標準ディレクトリ<br>

### ▲"ファイル名"
1. カレントディレクトリ<br>
2. オプションで指定された場所<br>
3. 環境変数などで定義される標準ディレクトリ<br>
<br>
　読み込まれたファイルは、構文規則に従って解釈されます。<br>
　なお、#includeで読み込まれたファイルの中でも、さらに#includeを用いてファイルを読み込めます。<br>

## 読み込むソースファイルが存在するかを確認する(__has_include) @version_C++17
　#includeでソースファイルを読み込む前に、そのソースファイルが存在するかを確認するために、__has_include命令を使用できます。この命令は、後述するプリプロセス時の分岐命令である#ifや#elseの文脈で使用でき、引数として#includeにわたすものと同じ形式でファイル名をしてします。<br>

<pre>
// 指定したファイル名のソースコードが存在していれば、
// インクルードする
#if __has_include(&lt;ファイル名&gt;)
    #include &lt;ファイル名&gt;
#endif
</pre>

　__has_include("ファイル名")もしくは__has_include(&lt;ファイル名&gt;)とすることで、指定したファイルが存在していれば条件式でtrueに評価され、存在していなければfalseに評価されます。<br>

　マクロは、プリプロセッサによって文字列を置換します。オブジェクト形式マクロと関数形式マクロの2種類があり、どちらも使用された場所で文字列を置換します。<br>
　オブジェクト形式マクロは以下のように定義し、ある値に別の名前を付けられます。<br>

<pre>
#define HOUR_OF_DAY 24
</pre>

　このオブジェクト形式マクロは、以下のように使用します。<br>

<pre>
const int hourOfDay = HOUR_OF_DAY;
</pre>

　このコードは、プリプロセッサによって、以下のように置換されます。<br>

<pre>
const int hourOfDay = 24;
</pre>

　関数形式マクロは以下のように定義し、関数のように使用できます。<br>

<pre>
#define SQUARE(VAL) VAL * VAL
</pre>

　この関数形式マクロの使用例は、以下のとおりです。<br>

<pre>
const int result = SQUARE(5);
</pre>

　このコードは、プリプロセッサによって、以下のように置換されます。<br>

<pre>
const int result = 5 * 5;
</pre>

　ここで注意が必要なのは、マクロが単なる文字列置換であるということです。<br>
　たとえば、上記のSQUARE関数マクロに5+5を実引数として渡した場合を考えてみましょう。10 * 10に展開されて100になることを期待しますが、実際には以下のように展開されるため、期待した結果を得られません。<br>

<pre>
const int result = 5 + 5 * 5 + 5; // resultには35が代入される
</pre>

　このようなことを避けるために、マクロ定義では仮引数を括弧でくくるようにしましょう。また、マクロが使用されている箇所の前後にある演算子の優先順により、期待と異なる演算結果とならないようにするため、マクロ全体も括弧でくくります。前述のSQUAREであれば、以下のようになります。<br>

<pre>
#define SQUARE(VAL) ((VAL) * (VAL))
</pre>

　先の式で、このマクロに5+5を実引数として渡すと、以下のように展開され、期待した結果が得られます。<br>

<pre>
const int result = ((5 + 5) * (5 + 5)); // resultは100
</pre>

　マクロ定義は#undefによって削除できます。前述のしたSQUAREを削除するには、以下のようにします。<br>

<pre>
#undef SQUARE
</pre>

　マクロは、名前空間や関数といったブロックに関係なく、定義された場所から#undefで定義を削除されるまで有効です。<br>
　#undefで定義を削除されなければ、ソースファイルの終端まで有効です。<br>

## オペランドの文字列化(#)
　関数マクロの仮引数に#をふかすることで、渡された実引数を文字列にできます。<br>

<pre>
#define TO_STRING(a) #a
</pre>

　これでaに渡された実引数が文字列リテラル化されます。<br>
　上記マクロを呼び出してみます。<br>

<pre>
const char* str = TO_STRING(string);
</pre>

　この式は以下のように展開されます。<br>

<pre>
const char* str = "string"
</pre>

## マクロ仮引数の連結(##)
　関数マクロの仮引数は、##により連結できます。<br>

<pre>
#define CONCATENATE(a, b) a##b
</pre>

　この関数マクロに、以下の実引数を与えて呼び出してみます。<br>

<pre>
CONCATENATE(Cplusplus, PocketReference)
</pre>

　すると、以下の結果が得られます。<br>

<pre>
CplusplusPocketReference
</pre>

## 条件付き取り込み(#if／#else／#elif／#endif)
　コンパイルの有効範囲を条件によって変更するのが、#ifを始めとするプリプロセッサディレクティブです。最も基本的な例を以下に示します。<br>

<pre>
#if 条件式
// 条件付き取り込み範囲
#endif
</pre>

　#ifに続く条件式の結果が0以外の場合、条件付き取り込み範囲がコンパイルされます。条件式の結果が0であれば、条件付き取り込み範囲はコンパイルされません。<br>
　条件式の成立、不成立でコンパイルする範囲を切り替えたい場合は、#elseディレクティブを使用し、以下のように記述します。<br>

<pre>
#if 条件式
// 条件式成立時コンパイル範囲
#else
// 条件式不成立時コンパイル範囲
#endif
</pre>

　さらに、#elifディレクティブを用いることで、条件を複数指定できます。<br>

<pre>
#if 条件式A
// 条件式A成立時コンパイル範囲
#elif 条件式B
// 条件式B成立時コンパイル範囲
#else
// 条件式Aおよび条件式Bともに不成立時コンパイル範囲
#endif
</pre>

　#ifから#endifまでの間に、複数の条件判定がある場合、最初に成立した条件判定以降の条件は評価されません。<br>
　したがって、上記のような条件判定の場合、条件式Aが成立すると、条件式A成立時コンパイル範囲しかコンパイルされません。<br>

### COLUMN 条件付き取り込みで使用される条件式
条件付き取り込みで使用される条件式は、整数の定数式で表され、結果が0であれば偽、0意外であれば真となります。<br>
#defineで定義されているマクロは、条件式で展開され、定数式の計算で使用されます。<br>
未定義の名前は0と解釈されます。たとえば、MACROというマクロ名が定義されていなければ、以下の条件式の結果は偽となります。<br>

<pre>
#if MACRO
</pre>

## マクロ定義判定(#ifdef／#ifndef／defined)
　#ifdefディレクティブを用いることで、マクロ定義の有無を条件として、条件付き取り込みを行えます。<br>

<pre>
#ifdef マクロ名
// マクロが定義されているときのコンパイル範囲
#endif
</pre>

　さらに、#ifndefディレクティブを用いることで、マクロが定義されていない時のコンパイル範囲も指定できます。<br>

<pre>
#ifndef マクロ名
// マクロが定義されていない時のコンパイル範囲
#endif
</pre>

　マクロ定義の判定には、defined演算子も使用できます。書式は以下のとおりです。<br>

<pre>
defined マクロ名
defined(マクロ名)
</pre>

　defined演算子は、指定されたマクロが定義されているいかどうかで、以下のように値を返します。<br>

- 指定されたマクロが定義されている場合 → 1を返す
- 指定されたマクロが定義されていない場合 → 0を返す

　defined演算子を用いてマクロ定義の判定を行う場合は、以下のように、#ifディレクティブや#elifディレクティブの条件式としてdefined演算子を用います。<br>

<pre>
#if defined(マクロA)
// マクロA定義時コンパイル範囲
#elif defined(マクロB)
// マクロB定義時コンパイル範囲
#else
// マクロAおよびマクロBともに未定義時コンパイル範囲
#endif
</pre>

　上記のとおり、判定するマクロが1つだけなら、#ifdefディレクティブと#ifディレクティブとdefined演算子の組み合わせは同じものです。しかし、defined演算子を用いたマクロ定義の判定では、論理式を使用できます。したがって、AND条件に&&、OR条件に||といった演算子を使用して、以下のような記述ができます。<br>

<pre>
// マクロA、Bいずれかが定義されているか
#if defined(マクロA) || defined(マクロB)
// 条件式成立時コンパイル範囲
#endif
</pre>

　if文と同様に、defined演算子は論理否定演算子(!)を用いて、条件式の結果を反転できます。<br>

## エラー出力(#error)
　エラーメッセージを出力したいときは、#errorディレクティブを用います。書式は以下のとおりです。<br>

<pre>
#error エラーメッセージ
</pre>

　以下の例のように、#ifディレクティブなどと組み合わせて、コンパイル時の条件によって、プログラマが任意のエラーを検出できます。<br>

<pre>
#if defined(VERSION) && VERSION < 3
#error Invalid version
#endif
</pre>

　プリプロセッサは、#errorディレクティブが現れると、その時点でプリプロセスをエラーで停止させます。<br>

## 定義済みマクロ
　次のマクロは、実装により定義されています。<br>

### ▲定義マクロと意味
|マクロ名|意味|
|:--|:--|
|&#095;&#095;cplusplus|C++のソースファイルで定義される。C++03では199711L、C++11では201103L、C++14では201402L、C++17では201703Lの値となる。|
|&#095;&#095;DATE&#095;&#095;|ソースファイルがコンパイルされた日付の"Mmm dd yyyy"形式の文字列リテラル|
|&#095;&#095;FILE&#095;&#095;|ソースファイル名の文字列リテラル|
|&#095;&#095;LINE&#095;&#095;|このマクロが記述されているソースファイル中の行番号の整数値|
|&#095;&#095;STOC_HOSTED&#095;&#095;|実装ホスト環境(OSの下で実行されるアプリケーションなど標準ライブラリの全機能が使用できる環境であれば1、そうでなければ0を返す|
|&#095;&#095;TIME&#095;&#095;|ソースファイルがコンパイルされた時間の"hh:mm:ss"形式の文字列|

実装により、これら以外の定義済みマクロも存在します。<br>

