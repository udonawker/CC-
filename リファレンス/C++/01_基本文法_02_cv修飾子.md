# cv 修飾子
## const
 const は変更できないことを表します。const就職されたオブジェクトは、生成時に決定された値を変更できません。<br>
<pre>
const int a = 1; // constオブジェクトの宣言
a = 2; // エラー : 変数は変更できない
</pre>
 constオブジェクトは、プログラム中で定数として扱えます。たとえば、以下のように配列の要素数を指定できます。
<pre>
const int count = 10;
int arr[count]; // 要素数10のint型の配列
</pre>
## constポインタ
 constはポインタにも適用できます。<br>
 ポインタの指し示す先をconstとして、constポインタを宣言する場合の例を以下に示します。<br>
<pre>
int a = 0;
const int* b = &a;
// int const* b = &a; // 上の行と同義
*b = 1;               // エラー : bはconst intへのポインタ
</pre>
 ポインタオブジェクトで、保持するアドレスを不変にしたい場合は、以下のように宣言します。<br>
<pre>
int* const b = &a;
</pre>
 この場合「bの保持するアドレスが不変」という宣言になるから、*bでアクセスするaの保持している値は書き換えることができます。<br>
 ポインタオブジェクトが保持するアドレスに加えて、指し示すオブジェクトの値も不変としたいのであれば、以下のように宣言します。<br>
<pre>
const int* const b = &a;
</pre>

## const参照
 const修飾子は、参照にも適用できます。ポインタより参照で使用されることの方が多いでしょう。const参照の例を以下に示します。<br>
<pre>
int a = 10;
const int & b = a;
b = 20; // エラー : bはconst就職されている
</pre>

## constメンバ関数
 const修飾は、クラスのメンバ関数にも適用できます。<br>
 const修飾されているメンバ関数は、そのメンバ関数が、クラスの状態を変更しないことを意味します。<br>
 クラスオブジェクトがconst宣言されている場合、const修飾されたメンバ関数のみ呼びたせます。<br>
 クラスに、同じ名前と同じシグネチャで、異なるcv修飾のメンバ関数が複数定義されている場合、constオブジェクトからは、const修飾されているメンバ関数が呼ばれます。<br>
<pre>
struct S {
    void f1();
    void f2() const;
    void f3();
    void f3() const;
};

const S s;
s.f1(); // エラー : f1はconstメンバ関数ではない
s.f2(); // OK
s.f3(); // const修飾されているf3がよばれる
</pre>
 const修飾されているメンバ関数の中では、thisポインタがconst修飾されているとみなされます。このため、mutable指定されているメンバ変数を除いて、メンバ変数は変更できません。<br>
 また、const修飾されているメンバ関数から自クラスのメンバ関数を呼び出す場合、そのメンバ関数もconst修飾されている必要があります。<br>
 なお、staticメンバ関数はconst修飾できません。<br>

## volatile
 volatile修飾されたオブジェクトは、プログラムに書かれたとおりにアクセスされます。したがって、volatile修飾されたオブジェクトに対するアクセスでは、コンパイラによる最適化が抑止されます。<br>
<pre>
int a = 10;
volatile int b = 20;
int c = a; // 最適化により、直接10が代入される可能性がある
int d = b; // 必ずbから代入される
a; // 無意味な式なので最適化でなくなる可能性がある
b; // 必ずbがアクセスされる
</pre>
 複数スレッドから同時にアクセスされる可能性のあるオブジェクトに対しては、volatileで最適化を抑止するのではなく、std::atomicもしくはミューテックスを使用しましょう。<br>

## volatileメンバ関数
 volatile修飾は、クラスのメンバ関数にも適用できます。<br>
 クラスオブジェクトがvolatile宣言されている場合、volatile修飾されたメンバ関数のみ呼びたせます。<br>
 クラスに、同じ名前と同じシグネチャで、異なるcv修飾のメンバ関数が複数定義されている場合、volatileオブジェクトからは、volatile修飾されているメンバ関数が呼ばれます。<br>
<pre>
struct S {
    void f1();
    void f2() volatile;
    void f3();
    void f3() volatile;
};

volatile S s;
s.f1(); // エラー : f1はvolatileメンバ関数ではない
s.f2(); // OK
s.f3();   // volatile修飾されているf3がよばれる
</pre>

### const修飾とvolatile修飾の混在
const修飾とvolatile修飾は、混在できます。つまり、以下のように修飾子た変数やメンバ関数を宣言できます。<br>
<pre>
const volatile int b = 10;
struct S {
    void f() const volatile;
}
</pre>
const volatile修飾は、必ずアクセスされる定数を表します。たとえば、ハードウェアが書き換えを行う読み取り専用のハードウェアレジスタのような、値が変更される可能性のあるオブジェクトへアクセスする変数の宣言などに用いられます。<br>

## cv修飾されたオブジェクトのメンバ関数呼び出し
 cv修飾された型で宣言されているオブジェクトへアクセスする場合、もしくは、cv修飾された参照もしくはポインタを介してオブジェクトへアクセスする場合には、同等か、それ以上のcv修飾がされているメンバ関数以外は呼び出せません。<br>
 
## const修飾されたオブジェクトのメンバ変数変更
 const修飾された型のオブジェクトはメンバ変数を書き換えられません。しかし、mutable指定されたメンバ変数に限り、const修飾された型のオブジェクトであっても変更できます。<br>
