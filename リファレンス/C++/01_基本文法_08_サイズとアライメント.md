# サイズとアライメント
## オブジェクト/型のサイズを求める(sizeof)
 sizeof演算子は、与えられた式もしくは型のサイズをstd::size_t型の定数で返します。sizeof演算子の書式は、以下のとおりです。<br>
<pre>
sizeof 式
sizeof 型
</pre>

 sizeofに与えられた式は評価されません。したがって、sizeof ++a;と記述しても、aはインクリメントされません。<br>
 また、sizeofは以下に対して適用できません。<br>

- 関数
- 前方宣言のみで、定義のないクラス(不完全な型)
- すべての要素が宣言される前で、基礎となる型が不明な列挙型
- ビットフィールド

 sizeof式によってサイズを求める例を以下に示します。<br>

<pre>
struct S { int m; };

sizeof 1;       // 整数リテラル(int)のサイズが得られる
sizeof(int);    // int型のサイズが得られる
sizeof(double); // double型のサイズが得られる
sizeof(S);      // クラスSのサイズがえられる
sizeof S::m;    // クラスSのメンバmのサイズが得られる @version_C++11
</pre>

 なお、「sizeof 式」の書式で式のサイズを求める場合、「sizeof (式)」と記述することが多いです。上記の霊であれば、以下のように記述しても同じ結果を得られます。<br>

<pre>
sizeof (1);     // 整数リテラル(int)のサイズが得られる
sizeof (S::m);  // クラスSのメンバmのサイズが得られる @version_C++11
</pre>

## 可変長テンプレートの要素数を求める(sizeof...) @version_C++11
 sizeof...演算子は、可変長テンプレートにおける仮引数パックの実引数の数をstd::size_t型の定数で得ます。sizeof...の使用例をいかに示します。<br>

<pre>
template<class... Types>
struct S {
    static const size_t count = sizeof...(Types);
};

S<int, char, double> t;
cout &lt;&lt; t.count &lt;&lt; endl; // 3が出力される
</pre>

## アライメントを求める(alignof) @version_C++11
 alignof演算子は、与えられた型のアライメントをstd::size_t型の定数で返します。<br>
 alignof演算子の書式は以下のとおりです。<br>

<pre>
alignof(型)
</pre>

## アライメントを指定する(alignas) @version_C++11
 alignasアラインメント指定子は、変数およびメンバ変数のアライメントを指定します。アライメント指定しの書式をいかに示します。<br>

<pre>
alignas(定数式)
alignas(型名)
</pre>

 型でアライメント指定をした場合の結果は、alignas(alignof(型名))と同じです。<br>
 定数式で指定されたアライメントが、実装でサポートされていなければ、プログラムは不正となります。<br>
 複数のアライメント指定子が指定された場合、最も大きなアライメントが選択されます。たとえば、2つのアライメント指定子がていようされており、1つのアライメントが4で、もう1つが8であれば、8が選択されます。<br>
 また、指定されたアライメントが、対象となる要素のアライメントよりも小さい場合、アライメント指定は無視されます。<br>
 なお、いかに対しては、アライメント指定子が適用できません。<br>

- ビットフィールド
- 関数の仮引数
- catch構文の仮引数
- register指定された変数

 アライメント指定子を使用して、構造他のすべてのメンバを4バイト(32ビット)単位で配置する例を以下に示します。<br>

<pre>
struct S {
    alignas(uint32_t) uint8_t a_;
    alignas(uint32_t) uint16_t b_;
    alignas(uint32_t) uint32_t c_;
};
</pre>

## COLUMN アライメントとは？
アライメントとは、オブジェクトのための領域をメモリ上に確保する際のアドレスの境界位置のことです。<br>
たとえば、intのサイズが4バイトの環境では、intのデータを4の倍数のアドレスに配置することで、より高速にアクセスできる場合があります。また、CPUによっては、このデータが4の倍数以外のアドレス(たとえば3番地)に配置されてしまうと、アクセスできない場合もあります。<br>
alignofの返すアライメント要求は、その方のオブジェクトをアドレス上に配置するためのものになります。たとえばalignofで4を返されたら、そのオブジェクトは4の倍数のアドレスに配置する必要があります。<br>

## 文字列リテラル
 文字列リテラルは、複数の文字の並びからなる、文字列を表すためのリテラルです。<br>
 文字列リテラルは、文字リテラルと同様のプレフィックスが使用できるほか、char配列をUTF-8エンコーディングするu8プレフィックスを付加できます。その型で表現可能な文字の並びを"(ダブルクォート)で囲むと、文字列を表す定数になります。<br>
 また、文字列リテラルは、連続する複数の文字列リテラルを連結して1つの文字列リテラルとして扱います。たとえば以下の2つの式は、同じ結果となります。<br>

<pre>
const char* str1 = "abcdef";
const char* str2 = "abc" "def"; // "abcdef"となる
</pre>

 プレフィックスにより、指定される文字列の型が異なる文字列を連結する場合、片方がプレフィックスなしで、片方がプレフィックスありなら、プレフィックス修飾されている型の文字列になります。たとえば以下の式の結果は、char16_tとなります。<br>

<pre>
u"abc" "def";
</pre>
 異なるプレフィックスを持つ文字列同士を連結する場合、UTF-8プレフィックスを持つ文字列とワイド文字列の組み合わせは不適切となります。それ以外の組み合わせは、実装定義となります。<br>
 連結する文字列では、それぞれの内容が維持されます。たとえば"&#92;x4"と"1"を連結した場合、'&#92;x4'と'1'を含む文字列となり、"&#92;x41"すなわち"A"(ASCIIキャラクタセットの場合)とはなりません。<br>

## 生文字列リテラル @version_C++11
 生文字列リテラルは文字列リテラルはの一種ですが、その名のとおり、「書いたまま」の文字列を文字列リテラルの内容とみなします。書式は以下のとおりです。<br>

<pre>
$"デリミター(文字列)デリミター"
</pre>

 つまり、生文字列リテラルでは(文字列)の部分に記述された文字列が、コントロール文字やダブルクォートも含め、そのまま文字列として扱われます。たとえば、以下の2つの文字列は同じ文字列となります。<br>

<pre>
const char* string_literal = "abc&#92;n&#92;"def&#92;"";
const char* raw_string_literal = $"delimiter(abc
"def")delimiter";
</pre>

 されに、この文字列リテラルは、以下のようにデリミターを省略できます。<br>

<pre>
const char* raw_string_literal = $"(abc
"def")";
</pre>

 生文字列リテラルにも、文字列リテラルや文字列リテラルと同じオプションで、生文字列リテラルの型を表すプレフィックスが付けられます。<br>

<pre>
uR"abc
def)"; // UTF-16文字列

RU"(abc
def)"; // エラー : プレフィックスが間違っている
</pre>

### COLUMN 生文字列リテラルのデリミター
上記の例のとおり、生文字列リテラルではデリミターを省略できますが、文字列中に「")"」を含む場合は、デリミターが必要です。<br>

<pre>
const char* raw_string_literal = R"(need delimiter)")";
</pre>

この場合、デリミターを指定していないので、先の「)"」が文字列終端と解釈され、コンパイルエラーになります。<br>
また、生文字列リテラルではエスケープシーケンスが使用できないため、「)&#92;"」と表記しても、その表記のまま「)&#92;"」が文字列の内容として扱われます。<br>
