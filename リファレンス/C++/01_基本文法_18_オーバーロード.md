# オーバーロード
## オーバーロードとは
　同じ関数名、演算子に対し、複数の定義を行うことをオーバーロードまたは多重定義と呼びます。<br>

### ▲関数オーバーロード
　関数のオーバーロードは、同じ名前の関数を複数定義する機能を提供します。<br>
　関数オーバーロードは、非メンバ関数、メンバ関数、コンストラクタに対して行えます。
　たとえば、累乗を計算するpower()関数に、整数用と浮動小数点用の2つがあるとすれば、それらは以下のように宣言されるでしょう。<br>

<pre>
int power(int x, int n);
double power(double x, int n);
</pre>

　そして、そのpower()関数の定義は以下のようになるでしょう。<br>

<pre>
int power(int x, int n) {
    int ret = 1;
    for (int i = 0; i < n; ++1) ret *= x;
    return ret;
}

double power(double x, int n) {
    double ret = 1.0;
    for (int i = 0; i < n; ++1) ret *= x;
    return ret;
}
</pre>

　オーバーロードされた関数は、それぞれ異なる仮引数りすとを持ちます。つまり、仮引数の数、もしくは型が異なっている必要があります。デフォルト実引数付きのオーバーロード関数の宣言はできますが、呼び出し時に曖昧さが発生するとエラーになります。たとえば、以下のようなオーバーロード関数があったとします。<br>

<pre>
int func(int x, int y = 10);
int func(int x);
</pre>

　この関数を呼び出す場合、以下のように実引数1つで呼ぼうとすると、どちらの関数を呼び出すのか判断できないため、エラーになります。<br>

<pre>
func(10); // エラー : func(int x, int y = 10)とfunc(int x)の
          // どちらか判断できない!
</pre>

　メンバ関数の場合は、さらに、cv修飾の違い、参照修飾子でもオーバーロードできます。<br>

### ▲演算子オーバーロード
　演算子オーバーロードは、仮引数のいずれかがユーザーによって定義された型をもつ演算子の挙動を定義します。仮引数がすべて組み込み型の演算子は、オーバーロードできません。オーバーロードされたユーザー定義の演算子は、通常の関数とみなされます。<br>

<pre>
struct X {}; // ユーザー定義の型
int operator+(const X& x, int a); // OK
int operator+(int, int); // NG
</pre>
