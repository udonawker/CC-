# メンバ変数／メンバ関数／メンバ型
## クラスメンバ
　クラスはメンバ変数、メンバ関数、およびメンバ型を持てます。メンバ変数はデータメンバ、メンバ関数はメソッドと呼ばれることもあります。<br>
　たとえば、アンケート結果を保存するためのクラスAnswerSheetを考えます。年齢ごとの傾向を知りたいため、年齢を保存するためのメンバage_、それに数値で保存されるアンケート結果のanswer_を持つものとします。<br>

<pre>
struct AnswerSheet {
    int age_;
    int answer_;
};
</pre>

　これでアンケート結果を保存するためのクラスAnswerSheetができました。アンケートを取る対象が100人いる場合、アンケート結果を保存する変数は配列を用いて以下のように宣言できます。<br>

<pre>
AnswerSheet answers[100];
</pre>

## メンバ変数
　先のAnswerSheetクラスはage_およびanswer_メンバを持っていました。これらはメンバ変数です。<br>

### ▲静的メンバ変数
　static指定子たメンバ変数は、静的メンバ変数となります。static指定されていない非静的メンバ変数は、クラスオブジェクト単位で生成されます。一方、静的メンバ変数は、生成されるクラスオブジェクトの数に関係なく、共有される実態を1つだけ持ちます。<br>
　静的メンバ変数は、実態を別に定義する必要があります。通常、ヘッダファイルではなく、ソースファイルに定義を記述します。<br>

<pre>
struct S {
    static int v;
};

int S::v; // 実態を定義しなければならない
</pre>

　const指定された整数型およびenum型、さらにconstexpr指定された任意の型の静的メンバは、クラスの宣言で初期化できます。<br>

<pre>
struct S {
    static const int v = 1;
};
</pre>

　なお、静的メンバ変数はmutableで宣言できません。<br>

### ▲非静的メンバ変数の定義箇所での初期化 @version_C++11
　メンバ変数は以下のようにデフォルト値を持てます。クラスオブジェクトを作成した際に初期化コードを記述する手間が省けますし、未初期化オブジェクトによって予期せぬ動作が起きるバグの発生を防げます。<br>

<pre>
struct AnswerSheet {
    // クラスのデフォルト値は未初期化がわかる値にしておく
    int age_ = -1;
    int answer_ = -1;
};
</pre>

### ▲mutable指定子
　メンバ変数をmutable指定すると、クラスオブジェクトがconstであったとしても、メンバ変数を書き換えられます。mutableの使用例を以下に示します。<br>

<pre>
struct S {
    mutable int value_ = 0;
    void setValue(int v) const {
        value_ = v; // const指定されたメンバ関数内でも、
                    // mutableオブジェクトの書き換えは可能
    }
};

const S s;

s.setValue(42); // constオブジェクトの値の書き換えができる
</pre>

## メンバ関数
