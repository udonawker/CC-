# スコープ
　スコープは、変数、関数、型定義などの有効範囲です。<br>
　プログラム中で参照される名前の解決は、スコープの範囲内で行われます。また、オブジェクトの生存期間も、そのオブジェクトが属するスコープの中となります。<br>
　グローバルスコープと、ステートメント中で宣言されたオブジェクトを除き、スコープ範囲は{}で囲まれたブロックとなり、入れ子にできます。入れ子にした場合、その外側のブロックも有効範囲になります。<br>

## グローバルスコープ
　グローバルスコープは、スコープ解決演算子を使用せずに、プログラム全体からアクセスできます。<br>
　グローバルスコープに所属するオブジェクトは、どの名前空間、関数、クラスにも所属していないものです。ただし、static指定されているもの、明示的にextern宣言されていないconstオブジェクトを除きます。<br>
　たとえば、以下の例の変数valueは、グローバルスコープに配置されています。<br>

<pre>
#include <iostream> // プログラムファイルの先頭行

int value = 42; // グローバルスコープのオブジェクト

int main() {}
</pre>

## 名前空間スコープ
　名前空間に所属するオブジェクトは、同じ名前空間からスコープ解決演算子による修飾無しでアクセスできます。入れ子にした名前空間では、自分が属する名前空間およびその外側の名前空間は修飾無しで参照できます。<br>
　名前空間スコープの例を以下に示します。<br>

<pre>
namespace NS1 {
    int value1 = 1;
    namespace NS2 {
        int value2 = 2;
        int func() {
            return value1 + value2; // value1/value2ともに見えている
        }
    }
    int func() {
        // value2を参照するにはスコープ解決演算子を使う必要がある
        return value1 * NS2::value2;
    }
}
</pre>

　名前空間スコープで宣言された静的オブジェクトの生存期間は、グローバルスコープオブジェクトと同じく、プログラム終了までです。<br>

## 関数スコープ
　関数内で宣言されたオブジェクトやクラスは、関数の最後まで有効です。オブジェクトは、staticでない限り、関数終了時に破棄されます。<br>
　以下の例のように、関数内で宣言されているオブジェクトは、関数スコープに属します。<br>

<pre>
void func() {
    int value; // この変数はfuncの中でしか見えない
}
</pre>

## ブロックスコープ
　{}で囲ったブロックでは、そのブロック内がスコープになります。ブロックスコープは、ステートメントと関係なく作成できます。<br>
　ブロックスコープで宣言されたstatic変数は、そのブロックに最初に入ったときに実行時初期化されます。以下の例での変数aは、一度だけ0に初期化されます。<br>

<pre>
for (int i = 0; i < 10; ++i) {
    static int a = i; // 一度だけ0に初期化される。1～9が代入されることはない
}
</pre>

 **static変数の実行時初期化はスレッドセーフです。**
 
 ## クラススコープ
　クラススコープは、クラス内で有効なスコープです。クラススコープに属するメンバは、同じクラス内の初期化式や関数から参照できます。<br>
　以下に暮らすスコープの例を示します。<br>

<pre>
struct S {
    const char* value = "Class S";
    decltype(value) getValue() const {
        return value; // S::valueが返る
    }
};
</pre>

　ほかのスコープでは後方参照による名前解決は行われませんが、クラススコープでは後方参照が有効です。<br>

<pre>
{
    cout << sizeof(a) << endl; // ブロックスコープではaを後方参照できないため、
                               // コンパイルエラー
    int a;
}

class C {
public:
    C() {
        cout << sizeof(a) << endl; // クラススコープでは後方参照できるため、
                                   // エラーとならない
    }

private:
    int a;
};
</pre>

## スコープとオブジェクトの隠蔽
　関数スコープ、ブロックスコープ、クラススコープで宣言されたオブジェクトは、以下のオブジェクトを隠蔽します。<br>

* グローバルスコープのオブジェクト
* 同じ名前空間に属するオブジェクト
* 同じ名前空間に属するオブジェクトのが外側のブロックで宣言されている同名のオブジェクト

　隠蔽されたグローバルスコープのオブジェクトや、名前空間に属するオブジェクトを参照したい場合は、スコープ解決演算子「::」を使用します。スコープ解決演算子の使用例を以下に示します。<br>

<pre>
namespace NS {
    int a;
}
NS::a = 10; // 名前空間NSで宣言されているaにアクセス
</pre>

