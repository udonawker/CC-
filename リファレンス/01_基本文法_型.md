## サイズを表す整数型
&lt;cstddef&gt;ヘッダおよび&lt;stddef.h&gt;では、sizeof演算子が返す符号なし整数型であるstd::size_t型が定義されています。<br/>
この型は、コンテナの要素数や添字の型としても使用されます。<br/>

## 変数
<pre>
型名 変数名 《= 初期化子》 ;
</pre>

## 配列
<pre>
型名 変数名[要素数] 《= 初期化子》 ;
</pre>

## ポインタ
《cv修飾子》 型名*《cv修飾子》 変数名 《= 初期化子》 ;

<pre>
int a = 0;
int* b = &a; // bはaのアドレスを保持するポインタオブジェクト
*b = 10; // aに10が代入される

int c[10] = {}; // 要素数10個、0で初期化された配列
int *d = c;     // dは配列cの先頭アドレスを保持するポインタオブジェクト
d[4] = 10;      // d[4]に10が代入される

int* f[10];     // 「int型へのポインタ」の要素を10個持つ配列
int** e = f;    // 「int型へのポインタ」へのポインタ
e[4] = nullptr; // f[4]にnullptrを代入
</pre>

### オブジェクトのアドレスを取得するには
&演算子はオーバーロードできます。このため、オブジェクトのアドレスを正しく取得できない可能性があります。<br/>
C++11以降の&lt;memory&gt;ヘッダで定義されているstd::addressof()関数を使用すると、オブジェクトの型に対する&演算子がオーバーロードされている／いないに関わらず、そのオブジェクトのアドレスを取得できます。<br/>
<pre>
X x;
X* p = addressof(x); // 変数xのアドレスを取得
</pre>

## 関数ポインタ
<pre>
戻り値の型 (*変数名)(仮引数リスト) 《= 初期化子》 ;
</pre>
<pre>
int square(int v) { return v * v; }
int (*f)(int) = square; // fは関数squareのアドレスを保持する関数ポインタオブジェクト
int result = f(5);      // 実引数5でsquareが呼ばれる。結果は25
</pre>

## メンバへのポインタ
<pre>
型 クラス名:: *変数名 《= 初期化子》 ;
戻り値の型 (クラス名 :: *変数名)(仮引数リスト) 《= 初期化子》 ;
</pre>

<pre>
struct S {
    int data;
    int square(int v) { return v * v; }
};

int S::*d = &S::data; // dはS::dataを指すメンバポインタ
int (S::*f)(int) = &S::square;

S s1;
S s2;
s1.*d = (s1.*f)(5); // 実引数5でs1.square()が呼ばれ、結果がs1.dataに代入される
s2.*d = (s2.*f)(7); // 実引数7でs2.square()が呼ばれ、結果がs2.dataに代入される
</pre>

## 参照
参照は、オブジェクトの別名のように振る舞います。参照の宣言は以下のように行います。<br/>
cv修飾子に関しては、別節参照
<pre>
《cv修飾子》 型名 &変数名 = 初期化子;
</pre>
<pre>
int a = 10;
int& b = a;  // bはaの参照
int& c;      // エラー。参照は必ず初期化されねばならない
int d = 30;
b = 20;      // aの値は20になる
b = d;       // 参照先は変更できない。dの値がaに代入され、aの値は30になる
</pre>
<pre>
const int& square(const int& v) {// ※仮引数と戻り値は参照
    static int result = v * v; // 静的宣言をしておかないと、戻った後破棄されてしまう
    return result;
}
</pre>

<pre>
struct S {
    int data = 0;
};

void fr(S& v);
void fr(int& v);
void fcr(const S& v);
void fcr(const int& v);

S s;
int a = 42;
fr(s); // オブジェクトを参照で渡す
fr(a); // オブジェクトを参照で渡す
// fr(S()); // エラー。一時オブジェクトを参照で渡すことはできない
// fr(42);  // エラー。整数リテラルを参照で渡すことはできない
fcr(S());   // 一時オブジェクトをconst参照で渡すことが可能
fcr(42);    // 制すリテラルconst参照で渡すことが可能

void fp(S* v);
void fp(int* v)

// fp(&S()); // エラー。一時オブジェクトのアドレスは取得できない
// fp(&42);  // エラー。整数リテラルのアドレスは取得できない
</pre>

## 列挙型
<pre>
enum TrafficLight { Blue, Yellow, Red };
TrafficLight light = Blue;
</pre>
<pre>
enum TrafficLight { Blue = 1, Yellow = 3, Red };
// Blueが1、Yellowが3、Redが4
</pre>

## スコープ付き列挙型 @version_C++11
<pre>
int Blue;
enum TrafficLight { Blue, Yellow, Red }; // Blueが重複しているのでエラー!
</pre>

<pre>
int Blue;
enum struct TrafficLight { Blue, Yellow, Red };
TrafficLight light = TrafficLight::Blue;
// スコープ付き列挙型の宣言において、structとclassの違いはない
</pre>

## 列挙型の基礎となる型の指定 @version_C++11
<pre>
enum struct TrafficLight : unsigned long { Blue, Yellow, Red };
</pre>

## 構造体
<pre>
struct Person {
    string name;
    int age;
    string address;
};
// C言語と違いC++では構造体のタグ名をそのまま型名として使用できます。
Person me;
// また、C言語と同じように、以下のように宣言することもできます。
struct Person me;
// さらに、typedef と同時に定義することもできます。これもC言語と同じです。
typedef struct name {} name;
</pre>

## ビットフィールド
<pre>
整数型 (メンバ変数名) : ビット長を表す定数式;
</pre>
メンバ変数名を省略した、無名ビットフィールドも作成できます。<br/>
無名ビットフィールドは、指定した長さの領域を確保できますが、その領域へはアクセスできません。<br/>
これはビット位置をあわせる場合などに使用されます。<br/>
また、無名ビットフィールドは、ビット長を0に指定できます。<br/>
ビット長が0の無名ビットフィールドは、指定した型の協会に合わせられるので、無名ビットフィールドに続くメンバ変数のビット位置を特定の型の教会に合わせたい場合に便利です。<br/>

<pre>
struct Bits {
    char    a : 2; // aは2bit長のchar型メンバ変数
    short     : 1; // 1bit長の空きを作る
    short   b : 3; // bは3bit長のshort型メンバ変数
    long      : 0; // 次のメンバはlong型の境界に合わせられる
    ing     c : 4; // cは4bit長のint型メンバ変数
    bool    d : 1; // dは1bit長のbool型メンバ変数
};
// ビットフィールド制約
// - ビットフィールドのアドレスは取得できない
// - ビットフィールドを参照へバインドする場合は、const参照のみバインドできる
// - staticメンバ変数のビットフィールドは宣言できない
</pre>

## クラス
<pre>
// 以下2つの宣言は等価
struct S {
    int m;
};
class S {
publid:
    int m;
};
// 以下2つの宣言は等価
class C {
    int m;
};
struct C {
private:
    int m;
};
</pre>

## 共用体
共用体は異なる型のオブジェクトを、同じアドレスに配置できます。<br/>
共用体の宣言は、構造体やクラスと似ていますが、メモリの配置が異なります。<br/>
共用体ではメンバ関数を除くすべてのメンバ変数が同じアドレスに配置されます。<br/>
例えば以下の共用体ではiとfが同じアドレスに配置されます。<br/>
<pre>
union U {
    int i;       // 整数型の変数
    float f;     // 単精度浮動小数点数型の変数
    void func(); // メンバ関数
};
</pre>
C++03では共用体はコンストラクタやデストラクタを持つクラスをメンバに持てません。<br/>
C++11以降は持てるようになっています。<br/>
C++11以降では、共用体はクラスに対して、以下の制限があります。<br/>
- 仮想関数を持てない
- 基底クラスを持てない
- 基底クラスになれない
- 静的メンバを持てない

共用体はクラスオブジェクトをメンバに持てますが、そのクラスが以下のメンバ関数を定義している場合、共用体の対応するメンバ関数は暗黙的に削除されます。<br/>
- デフォルトコンストラクタ
- コピーコンストラクタ
- ムーブコンストラクタ
- コピー代入演算子
- ムーブ代入演算子
- デストラクタ

これらのメンバ関数が必要であるなら、プログラマが明示的に定義しなければなりません。<br/>
また、共用体のメンバ変数であるクラスオブジェクトのクラスに、明示的に定義したコンストラクタがあれば初期化を、デストラクタがあれば破棄を、明示的に行わなければなりません。<br/>

<pre>
// 自前でコンストラクタおよびデストラクタを持つクラスSを定義
struct S {
    S() {}
    ~S() {}
};

union U {
    S s;             // Sクラスのオブジェクトs
    vector<int> v;   // vector<int>クラスのオブジェクトv
    
    U() {}           // Sおよびvectorは、デフォルトコンストラクタを定義しているので、Uはデフォルトコンストラクタを定義しなければならない
    ~U() {}          // Sおよびvectorは、デストラクタを定義しているので、Uはデストラクタを定義しなければならない
};

U u; // 共用体のオブジェクト

// 初期化のため、明示的にコンストラクタを呼び出す
new (&u.s) S();
// 異なる型のオブジェクトを使用するため明示的にデストラクタを呼び出す
u.s.~S();

// 初期化のため、明示的にコンストラクタを呼び出す
new (&u.v) vector<int>({0, 1, 2});
// 異なる型のオブジェクトを使用するため明示的にデストラクタを呼び出す
u.v.~vector();
</pre>

# cv 修飾子
## const
 const は変更できないことを表します。const就職されたオブジェクトは、生成時に決定された値を変更できません。<br>
<pre>
const int a = 1; // constオブジェクトの宣言
a = 2; // エラー : 変数は変更できない
</pre>
 constオブジェクトは、プログラム中で定数として扱えます。たとえば、以下のように配列の要素数を指定できます。
<pre>
const int count = 10;
int arr[count]; // 要素数10のint型の配列
</pre>
## constポインタ
 constはポインタにも適用できます。<br>
 ポインタの指し示す先をconstとして、constポインタを宣言する場合の例を以下に示します。<br>
<pre>
int a = 0;
const int* b = &a;
// int const* b = &a; // 上の行と同義
*b = 1;               // エラー : bはconst intへのポインタ
</pre>
 ポインタオブジェクトで、保持するアドレスを不変にしたい場合は、以下のように宣言します。<br>
<pre>
int* const b = &a;
</pre>
 この場合「bの保持するアドレスが不変」という宣言になるから、*bでアクセスするaの保持している値は書き換えることができます。<br>
 ポインタオブジェクトが保持するアドレスに加えて、指し示すオブジェクトの値も不変としたいのであれば、以下のように宣言します。<br>
<pre>
const int* const b = &a;
</pre>

## const参照
 const修飾子は、参照にも適用できます。ポインタより参照で使用されることの方が多いでしょう。const参照の例を以下に示します。<br>
<pre>
int a = 10;
const int & b = a;
b = 20; // エラー : bはconst就職されている
</pre>

## constメンバ関数
 const修飾は、クラスのメンバ関数にも適用できます。<br>
 const修飾されているメンバ関数は、そのメンバ関数が、クラスの状態を変更しないことを意味します。<br>
 クラスオブジェクトがconst宣言されている場合、const修飾されたメンバ関数のみ呼びたせます。<br>
 クラスに、同じ名前と同じシグネチャで、異なるcv修飾のメンバ関数が複数定義されている場合、constオブジェクトからは、const修飾されているメンバ関数が呼ばれます。<br>
<pre>
struct S {
    void f1();
    void f2() const;
    void f3();
    void f3() const;
};

const S s;
s.f1(); // エラー : f1はconstメンバ関数ではない
s.f2(); // OK
s.f3(); // const修飾されているf3がよばれる
</pre>
 const修飾されているメンバ関数の中では、thisポインタがconst修飾されているとみなされます。このため、mutable指定されているメンバ変数を除いて、メンバ変数は変更できません。<br>
 また、const修飾されているメンバ関数から自クラスのメンバ関数を呼び出す場合、そのメンバ関数もconst修飾されている必要があります。<br>
 なお、staticメンバ関数はconst修飾できません。<br>

## volatile
 volatile修飾されたオブジェクトは、プログラムに書かれたとおりにアクセスされます。したがって、volatile修飾されたオブジェクトに対するアクセスでは、コンパイラによる最適化が抑止されます。<br>
<pre>
int a = 10;
volatile int b = 20;
int c = a; // 最適化により、直接10が代入される可能性がある
int d = b; // 必ずbから代入される
a; // 無意味な式なので最適化でなくなる可能性がある
b; // 必ずbがアクセスされる
</pre>
 複数スレッドから同時にアクセスされる可能性のあるオブジェクトに対しては、volatileで最適化を抑止するのではなく、std::atomicもしくはミューテックスを使用しましょう。<br>

## volatileメンバ関数
 volatile修飾は、クラスのメンバ関数にも適用できます。<br>
 クラスオブジェクトがvolatile宣言されている場合、volatile修飾されたメンバ関数のみ呼びたせます。<br>
 クラスに、同じ名前と同じシグネチャで、異なるcv修飾のメンバ関数が複数定義されている場合、volatileオブジェクトからは、volatile修飾されているメンバ関数が呼ばれます。<br>
<pre>
struct S {
    void f1();
    void f2() volatile;
    void f3();
    void f3() volatile;
};

volatile S s;
s.f1(); // エラー : f1はvolatileメンバ関数ではない
s.f2(); // OK
s.f3();   // volatile修飾されているf3がよばれる
</pre>

### const修飾とvolatile修飾の混在
const修飾とvolatile修飾は、混在できます。つまり、以下のように修飾子た変数やメンバ関数を宣言できます。<br>
<pre>
const volatile int b = 10;
struct S {
    void f() const volatile;
}
</pre>
const volatile修飾は、必ずアクセスされる定数を表します。たとえば、ハードウェアが書き換えを行う読み取り専用のハードウェアレジスタのような、値が変更される可能性のあるオブジェクトへアクセスする変数の宣言などに用いられます。<br>

## cv修飾されたオブジェクトのメンバ関数呼び出し
 cv修飾された型で宣言されているオブジェクトへアクセスする場合、もしくは、cv修飾された参照もしくはポインタを介してオブジェクトへアクセスする場合には、同等か、それ以上のcv修飾がされているメンバ関数以外は呼び出せません。<br>
 
## const修飾されたオブジェクトのメンバ変数変更
 const修飾された型のオブジェクトはメンバ変数を書き換えられません。しかし、mutable指定されたメンバ変数に限り、const修飾された型のオブジェクトであっても変更できます。<br>
