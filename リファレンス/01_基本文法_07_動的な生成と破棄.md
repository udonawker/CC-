# 動的な生成と破棄
## オブジェクトの動的な生成と破棄(new/delete)
 オブジェクトを動的に生成するには、new演算子を使用します。new演算子は、オブジェクトを格納するメモリを確保し、初期化を行った後、そのメモリのアドレスを返します。もしメモリの確保に失敗すると、std::bad_alloc例外が送出されます。<br>
 new演算子は、以下のように使用します。
<pre>
int* p = new int;
</pre>

 new演算子で配列を確保する場合は、以下のように記述します。<br>
<pre>
int* p = new int[10];
</pre>
 配列のサイズに0未満、もしくは実装で確保できる上限のサイズを超える値を指定すると、std::bad_array_new_length例外が送出されます。<br>
 new演算子でメモリを確保するとき、std::nothrowと組み合わせると、メモリ確保に失敗した場合に、例外を送出するのではなく、nullptrを返すようになります。<br>

<pre>
int *p = new(nothrow) int;
</pre>

 new演算子で確保したメモリは、deleteで開放する必要があります。delete演算子は、以下のように使用します。<br>

<pre>
delete p;
</pre>

 new[]演算子で確保された配列を開放するには、delete[]演算子を使用します。<br>

<pre>
delete[] p;
</pre>

## COLUMN new/deleteとメモリリーク
new演算子で確保した領域は、deleteによる開放を忘れると、メモリリークという問題を引き起こします。<br>
この問題を防ぐ方法として、標準ライブラリが提供している、shared_ptrのようなスマートポインタやvectorなどのコンテナを積極的に使用することが挙げられます。<br>

## 配置new
 new演算子には、配置newと呼ばれる構文があります。この構文を用いることで、任意のクラスを任意のメモリオブジェクトへ配置できます。配置newの例を以下に示します。<br>

<pre>
struct S {};

void* p = malloc(sizeof(S)); // Sのメモリを確保
S* obj = new(p) S;           // 確保したメモリにSを配置
obj->~S();                   // Sの破棄
free(p);                     // メモリの開放
</pre>
